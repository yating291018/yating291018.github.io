{"pages":[],"posts":[{"title":"面试题&#x2F;面试题总结","text":"1. 合并两个数组 concat、for 循环、扩展运算法、push.apply 这些方法都可以 2. 合并两个对象 Object.assign、扩展运算法、手写深浅拷贝 都可以 3. interface 和 type 的区别 都可以描述一个对象interface UserOP { name: string age: number}type UserOP { name: string age: number} 都可以描述一个函数interface SetUse { (name: string, email: string): UserOP}type SetUse = (name: string, email: string) =&gt; void interface extends interfacetype UserType = NameType &amp; { age: number } 不同点 type DiffName = string 可以申明基本类型 interface Dog { wong()}interface Cat { miao()}type Pet = Dog | Cat 联合类型 type PetList = [Dog, Pet]interface可以申明合并 flex: 0 1 auto 表示什么意思 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 求最终 left、right 的宽度 1234567891011121314151617181920212223&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; * { padding: 0; margin: 0; } .container { width: 600px; height: 300px; display: flex; } .left { flex: 1 2 500px; background: red; } .right { flex: 2 1 400px; background: blue; }&lt;/style&gt; 12345678910111213141516171819子元素的 flex-shrink 的值分别为 2，1溢出：500+400 - 600 = 300。总权重为 2 * 500+ 1 * 400 = 1400两个元素分别收缩：300 * 2(flex-shrink) * 500(width) / 1400= 214.28300 * 1(flex-shrink) * 400(width) / 1400= 85.72三个元素的最终宽度分别为：500 - 214.28 = 285.72400 - 85.72 = 314.28如果container的宽度是1000px, left 和 right 的宽度是怎么计算的子元素的 flex-grow的值分别为 1，2剩余空间：1000 - 500+400= 100。子元素所得到的多余空间分别为：100 * 1 / 3= 33.33100 * 2 / 3 = 66.67子元素最终宽度分别为：500 + 33.33 = 533.33400 + 66.67 =466.67 求字符串数组的最长公共前缀比如输入: [“flower”,”flow”,”flight”]，输出: “fl” 解题思路：找到最大和最小值，最大值和最小值的公共前缀就是 123456789101112131415var longestCommonPrefix = function(strs) { if (strs === null || strs.length === 0) return \"\"; if(strs.length === 1) return strs[0] let min = 0, max = 0 for(let i = 1; i &lt; strs.length; i++) { if(strs[min] &gt; strs[i]) min = i if(strs[max] &lt; strs[i]) max = i } for(let j = 0; j &lt; strs[min].length; j++) { if(strs[min].charAt(j) !== strs[max].charAt(j)) { return strs[min].substring(0, j) } } return strs[min]}; 获取首屏时间 H5 如果页面首屏有图片首屏时间 = 首屏图片全部加载完毕的时刻 - performance.timing.navigationStart如果页面首屏没有图片首屏时间 = performance.timing.domContentLoadedEventStart - performance.timing.navigationStart小程序通过拦截 setData 调用方式计算关于performance的介绍 git rebase 和 merge 的区别 主要的区别在于是否保留分支的 commit 提交节点，rebase 会给你一个简洁的线性历史树关于git rebase 和 git merge的区别 大型复杂项目开发协作经验、遇到的问题和解决方案 git 协作流程 如果让你负责一个新项目，如何选择技术栈，如何避免多端合作可能遇到的问题 脚手架开发、约定团队开发规范、Lint 等；根据团队的技术栈、成员能力等去选择 TSLint、ESLint 的区别 介绍一些开源框架的原理 Koa、Axios、Vue、React、Taro 等 性能监控的一些实现原理，包括异常、网络请求、加载时间等 npm 版本号 ^ ~ 的区别 脱字符(^)来限定所安装模块的主版本号 ^1.2.1 代表的更新版本范围为 &gt;=1.2.1 &amp;&amp; &lt; 2.0.0，即 1.x ^0.2.1 代表的更新版本范围为 &gt;=0.2.1 &amp;&amp; &lt; 0.3.0，即 0.2.x ^0.0.2 代表的更新版本范围为 0.0.2（相当于锁定为了0.0.2版本），即 0.0.2 波浪号(~)是限定模块的次要版本 ~1.5.1允许安装版本号大于1.5.1但小于1.6.0版本的模块，即 1.5.x ~0.5.1允许安装版本号为0.6.0，即0.5.x 埋点数据上报的方案 Ajax 请求、img、script img 天然支持跨域；跨域友好、不占用 Ajax 请求、执行无阻塞 介绍原型鸡生蛋、蛋生鸡问题 Object instanceof Function Function instanceof Object Object instanceof Object Function instanceof 原型链问题 手写深拷贝 深拷贝问题 模拟实现 Array.prototype.splice 123456789101112131415161718Array.prototype.spliceMy = function (startIndex, endIndex, ...item) { if (startIndex &lt; 0) { startIndex = this.length + startIndex endIndex = this.length + startIndex + endIndex } else { endIndex = startIndex + endIndex } let arrStart = this.slice(0, startIndex) let arrEnd = this.slice(endIndex, this.length) console.log(arrStart, arrEnd) let returnArr = this.slice(startIndex, endIndex) let newArr = arrStart.concat(item).concat(arrEnd) for (let i = 0; i &lt; newArr.length; i++) { this[i] = newArr[i]; } this.length = newArr.length return returnArr}","link":"/2020/05/28/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"面试题&#x2F;面试题2","text":"实现节流 1234567891011121314151617181920212223242526272829303132function throttle(func, wait, options) { let time, context, args, result; let previous = 0; if (!options) options = {}; let later = function() { previous = options.leading === false ? 0 : new Date().getTime(); time = null; func.apply(context, args); if (!time) context = args = null; }; let throttled = function() { let now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; let remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) { if (time) { clearTimeout(time); time = null; } previous = now; func.apply(context, args); if (!time) context = args = null; } else if (!time &amp;&amp; options.trailing !== false) { time = setTimeout(later, remaining); } }; return throttled;} 解析url的query参数 12345678910111213141516171819202122function searchObj(str){ //去掉？ var str=str.slice(1); //根据“&amp;”分割字符串 var arr=str.split(\"&amp;\"); //定义空的obj，保存对象 var obj={}; //循环遍历分割后的数组 for(var p of arr){ //根据“=”分割 var arr2=p.split(\"=\"); //解构 var [name,value]=arr2; //如果obj中的name为undefined就把值填进去，否则就连接 if(obj[name]==undefined){ obj[name]=value; }else{ obj[name]=[].concat(value,obj[name]) } } return obj;}","link":"/2020/05/28/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%982/"},{"title":"jsbase&#x2F;工作中问题总结","text":"数字字符串的比较JavaScript中常用数字字符串比较 1、数字与数字之间直接比较 比较方式依据数学运算，没什么好说的。 2、数字与字符串数字之间直接比较 例如 数字5 与字符串数字’123’，这种比较先将数字字符串转为纯数字，然后为纯数字间的比较 3、字符串数字与字符串数字之间直接比较 例如 ‘5’和‘123’比较 这种比较为ASCII码比较，依次取每个字符，字符转为ASCII码进行比较 ‘5’&gt;’123’ ==&gt;true 4、字符串之间直接比较 大小比较是依次取字符，字符转ASCII码，ASCII码先大的即为大；","link":"/2020/05/28/jsbase/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"算法&#x2F;前端算法","text":"111111","link":"/2020/05/28/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/"},{"title":"vue源码&#x2F;vue源码解析","text":"1111","link":"/2020/05/28/vue%E6%BA%90%E7%A0%81/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}],"tags":[],"categories":[]}