{"pages":[],"posts":[{"title":"SpringBoot&#x2F;exception","text":"springBoot的异常处理 1. 全局异常处理扑获 定义一个异常类，使用@RestControllerAdvice注解，可以扑获异常。 定义具体异常方法，使用@ExceptionHander(value = Exception.class) Exception.class可以是其他异常类的反射，异常扑获方法，可以扑获对应异常类的信息。 异常方法有三个参数HttpServetRequest req, Exception e, HttpServerResponse resp需要定义CustomException继承RuntimeException类，不然throw不会被扑获12345678910111213141516171819202122@RestControllerAdvice // 异常类public class GobalExceptionHandler { // 只有要异常就会调用这个方法，Exception.class是扑获全部异常 @ExceptionHandler(value = Exception.class) public Map&lt;String, Object&gt; handlerException(HttpServletRequest req, Exception e) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"returnCode\", 500); map.put(\"returnMessage\", e.toString().substring(e.toString().indexOf(\":\") + 1)); map.put(\"returnData\", \"系统异常\"); return map; } // 会监听runtimeException的异常，这个可以自定一异常 @ExceptionHandler(value = CustomException.class) public ErrorResponseEntity handlerCustomException(HttpServletRequest req, Exception e) { // 把异常转为具体异常信息 CustomException ce = (CustomException) e; // 返回具体结构 return new ErrorResponseEntity(ce.getReturnCode(), ce.getReturnMessage()); }} 在具体的Controller里面，如果校验不通过就可以使用 throw new CustomException() 抛出继承RuntimeException的类。","link":"/2020/06/11/SpringBoot/exception/"},{"title":"SpringBoot&#x2F;mybatis","text":"mybatis的使用 springboot扫描注解的时候，自动过滤调接口和抽象类。所有dao里的接口无法@Autowire,在启动类上添加@MapperScan(basePackage={“com.yatinghu.dao.*”}) 可以在dao的接口中添加@Mapper","link":"/2020/06/16/SpringBoot/mybatis/"},{"title":"SpringBoot&#x2F;responResult","text":"统一返回值结构类型 定义一个统一的返回值结构类型123456789101112@Datapublic class ResponseResult&lt;T&gt; { private int returnCode; private String returnMessage; private T data; // 泛型类的构造函数不用写范型 public ResponseResult(int returnCode, String returnMessage, T data) { this.returnCode = returnCode; this.returnMessage = returnMessage; this.data = data; }}","link":"/2020/06/11/SpringBoot/responResult/"},{"title":"SpringBoot&#x2F;跨域设置","text":"跨域设置 springboot设置跨域方法，三种 方式一(精细配置) 在需要跨域的整个Controller或者单个方法上添加@CrossOrigin注解 方式二(全局配置) 1234567891011@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowedMethods(\"POST\", \"GET\", \"PUT\", \"OPTIONS\", \"DELETE\") .maxAge(3600) .allowCredentials(true); }} 还可以结合读取配置文件信息使用@PropertySource(“classpath:application.properties”), 然后使用@Value(“${server.port}”)注入到变量中使用","link":"/2020/06/11/SpringBoot/%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AE/"},{"title":"SpringBoot&#x2F;设置统一响应头","text":"设置统一响应头 需要设置自定义响应头, 使用@Configuration组册配置，就可以被springboot的aop执行 也可以在每一个Controller中使用resp设置12345678910@Configurationpublic class EncodeFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {// System.out.println(\"进入了过滤器起\"); httpServletResponse.setHeader(\"autoparams\", \"111111111\"); filterChain.doFilter(httpServletRequest, httpServletResponse); }}","link":"/2020/06/11/SpringBoot/%E8%AE%BE%E7%BD%AE%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E5%A4%B4/"},{"title":"jsbase&#x2F;yarn的使用","text":"yarn的使用 查看使用的镜像源yarn config get registry | npm config get registry 修改为淘宝的镜像源yarn config set registry https://registry.npm.taobao.org/","link":"/2020/07/03/jsbase/yarn%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"jsbase&#x2F;input的一些问题","text":"input的一些问题。 accept可以限制哪些文件可以上传，但是无法完全限制住，可以绕过。要在提交的时候，得到文件的具体文件来限制大小，文件类型。 accept的用法有两中，第一种：accept=”.xls,.xlsx’直接使用后缀，通过后缀过滤。 第二种： accept=”application/octet-stream” 这种mime类型。问题：wps也要兼容。","link":"/2020/07/03/jsbase/input%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"title":"算法&#x2F;前端算法","text":"二叉树的前序，中序，后序遍历。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 基本节点class Node { constructor (data) { this.data = data this.left = null this.right = null }}class BinaryTree { constructor () { this.root = null } insertNode (node, newNode) { if (node.data &gt; newNode.data) { if (node.left === null) { node.left = newNode } else { this.insertNode(node.left, newNode) } } else { if (node.right === null) { node.right = newNode } else { this.insertNode(node.right, newNode) } } } show (node) { console.log(node.data) } // 插入二叉树 insert (data) { let newNode = new Node(data) if (this.root === null) { this.root = newNode } else { this.insertNode(this.root, newNode) } } // 先序遍历 preOrder (node, callback) { if (node) { callback(node) this.preOrder(node.left, callback) this.preOrder(node.right, callback) } } // 中序遍历 inOrder (node, callback) { if (node) { this.inOrder(node.left, callback) callback(node) this.inOrder(node.right, callback) } } // 后许遍历 postOrder (node, callback) { if (node) { this.postOrder(node.left, callback) this.postOrder(node.right, callback) callback(node) } }} 问：共有n个台阶，每次只能上1个台阶或者2个台阶，共有多少种方法爬完台阶？共有n页书，每次只能翻1页或者2页书，共有多少种方法翻完全书？ 1234567891011121314151617181920212223242526272829 function fibonacci(n) { if (n === 1 || n === 2) { return 1; } else { return fibonacci(n-1) + fibonacci(n-2) }}// 一个记忆化的斐波那契数列let tem = [0, 1]function fibonacci(n) { let result = tem[n] if(typeof result !== 'number') { result = fibonacci(n-1)+fibonacci(n-2) tem[n] = result // 将每次 fibonacci(n) 的值都缓存下来 } return result}// 动态规划：从底部开始解决问题， 将所有小问题解决掉， 然后合并成一个整体解决方案， 从而解决掉整个大问题 。function fibonacci(n) { let last = 1; let nextLast = 1; let result = 1; for (let i = 2; i &lt; n; ++i) { result = last + nextLast; last = nextLast; nestLast = result; } return result;}","link":"/2020/05/28/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/"},{"title":"vue源码&#x2F;vue源码解析","text":"1111","link":"/2020/05/28/vue%E6%BA%90%E7%A0%81/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"jsbase&#x2F;工作中问题总结","text":"数字字符串的比较JavaScript中常用数字字符串比较 1、数字与数字之间直接比较 比较方式依据数学运算，没什么好说的。 2、数字与字符串数字之间直接比较 例如 数字5 与字符串数字’123’，这种比较先将数字字符串转为纯数字，然后为纯数字间的比较 3、字符串数字与字符串数字之间直接比较 例如 ‘5’和‘123’比较 这种比较为ASCII码比较，依次取每个字符，字符转为ASCII码进行比较 ‘5’&gt;’123’ ==&gt;true 4、字符串之间直接比较 大小比较是依次取字符，字符转ASCII码，ASCII码先大的即为大； http缓存问题 2、Cache-Control catche-control是http1.1提出的概念，优先级高于expires，描述的是一个相对时间 Cache-Control: max-age=315360000 除了max-age外，cache-control还有其他几个参数： -no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 -no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 -public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 -private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 200：强缓Expires/Cache-Control存失效时，返回新的资源文件 200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功 304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304 现在的200(from cache)已经变成了from disk cache(磁盘缓存)和from memory cache(内存缓存)两种，而这两种方式又有什么区别呢： from memory cache：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况。 from disk cache：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache。 下表统计了这两种类型各会存储的资源： http状态 类型 说明 200 from memory cache 一般脚本、字体、图片会存在内存当中 200 from disk cache 一般非脚本会存在内存当中，如css等","link":"/2020/05/28/jsbase/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"面试题&#x2F;面试题总结","text":"1. 合并两个数组 concat、for 循环、扩展运算法、push.apply 这些方法都可以 2. 合并两个对象 Object.assign、扩展运算法、手写深浅拷贝 都可以 3. interface 和 type 的区别 都可以描述一个对象interface UserOP { name: string age: number}type UserOP { name: string age: number} 都可以描述一个函数interface SetUse { (name: string, email: string): UserOP}type SetUse = (name: string, email: string) =&gt; void interface extends interfacetype UserType = NameType &amp; { age: number } 不同点 type DiffName = string 可以申明基本类型 interface Dog { wong()}interface Cat { miao()}type Pet = Dog | Cat 联合类型 type PetList = [Dog, Pet]interface可以申明合并 flex: 0 1 auto 表示什么意思 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 求最终 left、right 的宽度 1234567891011121314151617181920212223&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; * { padding: 0; margin: 0; } .container { width: 600px; height: 300px; display: flex; } .left { flex: 1 2 500px; background: red; } .right { flex: 2 1 400px; background: blue; }&lt;/style&gt; 12345678910111213141516171819子元素的 flex-shrink 的值分别为 2，1溢出：500+400 - 600 = 300。总权重为 2 * 500+ 1 * 400 = 1400两个元素分别收缩：300 * 2(flex-shrink) * 500(width) / 1400= 214.28300 * 1(flex-shrink) * 400(width) / 1400= 85.72三个元素的最终宽度分别为：500 - 214.28 = 285.72400 - 85.72 = 314.28如果container的宽度是1000px, left 和 right 的宽度是怎么计算的子元素的 flex-grow的值分别为 1，2剩余空间：1000 - 500+400= 100。子元素所得到的多余空间分别为：100 * 1 / 3= 33.33100 * 2 / 3 = 66.67子元素最终宽度分别为：500 + 33.33 = 533.33400 + 66.67 =466.67 求字符串数组的最长公共前缀比如输入: [“flower”,”flow”,”flight”]，输出: “fl” 解题思路：找到最大和最小值，最大值和最小值的公共前缀就是 123456789101112131415var longestCommonPrefix = function(strs) { if (strs === null || strs.length === 0) return \"\"; if(strs.length === 1) return strs[0] let min = 0, max = 0 for(let i = 1; i &lt; strs.length; i++) { if(strs[min] &gt; strs[i]) min = i if(strs[max] &lt; strs[i]) max = i } for(let j = 0; j &lt; strs[min].length; j++) { if(strs[min].charAt(j) !== strs[max].charAt(j)) { return strs[min].substring(0, j) } } return strs[min]}; 获取首屏时间 H5 如果页面首屏有图片首屏时间 = 首屏图片全部加载完毕的时刻 - performance.timing.navigationStart如果页面首屏没有图片首屏时间 = performance.timing.domContentLoadedEventStart - performance.timing.navigationStart小程序通过拦截 setData 调用方式计算关于performance的介绍 git rebase 和 merge 的区别 主要的区别在于是否保留分支的 commit 提交节点，rebase 会给你一个简洁的线性历史树关于git rebase 和 git merge的区别 大型复杂项目开发协作经验、遇到的问题和解决方案 git 协作流程 如果让你负责一个新项目，如何选择技术栈，如何避免多端合作可能遇到的问题 脚手架开发、约定团队开发规范、Lint 等；根据团队的技术栈、成员能力等去选择 TSLint、ESLint 的区别 介绍一些开源框架的原理 Koa、Axios、Vue、React、Taro 等 性能监控的一些实现原理，包括异常、网络请求、加载时间等 npm 版本号 ^ ~ 的区别 脱字符(^)来限定所安装模块的主版本号 ^1.2.1 代表的更新版本范围为 &gt;=1.2.1 &amp;&amp; &lt; 2.0.0，即 1.x ^0.2.1 代表的更新版本范围为 &gt;=0.2.1 &amp;&amp; &lt; 0.3.0，即 0.2.x ^0.0.2 代表的更新版本范围为 0.0.2（相当于锁定为了0.0.2版本），即 0.0.2 波浪号(~)是限定模块的次要版本 ~1.5.1允许安装版本号大于1.5.1但小于1.6.0版本的模块，即 1.5.x ~0.5.1允许安装版本号为0.6.0，即0.5.x 埋点数据上报的方案 Ajax 请求、img、script img 天然支持跨域；跨域友好、不占用 Ajax 请求、执行无阻塞 介绍原型鸡生蛋、蛋生鸡问题 Object instanceof Function Function instanceof Object Object instanceof Object Function instanceof 原型链问题 手写深拷贝 深拷贝问题 模拟实现 Array.prototype.splice 123456789101112131415161718Array.prototype.spliceMy = function (startIndex, endIndex, ...item) { if (startIndex &lt; 0) { startIndex = this.length + startIndex endIndex = this.length + startIndex + endIndex } else { endIndex = startIndex + endIndex } let arrStart = this.slice(0, startIndex) let arrEnd = this.slice(endIndex, this.length) console.log(arrStart, arrEnd) let returnArr = this.slice(startIndex, endIndex) let newArr = arrStart.concat(item).concat(arrEnd) for (let i = 0; i &lt; newArr.length; i++) { this[i] = newArr[i]; } this.length = newArr.length return returnArr}","link":"/2020/05/28/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"面试题&#x2F;面试题2","text":"实现节流 1234567891011121314151617181920212223242526272829303132function throttle(func, wait, options) { let time, context, args, result; let previous = 0; if (!options) options = {}; let later = function() { previous = options.leading === false ? 0 : new Date().getTime(); time = null; func.apply(context, args); if (!time) context = args = null; }; let throttled = function() { let now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; let remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) { if (time) { clearTimeout(time); time = null; } previous = now; func.apply(context, args); if (!time) context = args = null; } else if (!time &amp;&amp; options.trailing !== false) { time = setTimeout(later, remaining); } }; return throttled;} 解析url的query参数 12345678910111213141516171819202122function searchObj(str){ //去掉？ var str=str.slice(1); //根据“&amp;”分割字符串 var arr=str.split(\"&amp;\"); //定义空的obj，保存对象 var obj={}; //循环遍历分割后的数组 for(var p of arr){ //根据“=”分割 var arr2=p.split(\"=\"); //解构 var [name,value]=arr2; //如果obj中的name为undefined就把值填进去，否则就连接 if(obj[name]==undefined){ obj[name]=value; }else{ obj[name]=[].concat(value,obj[name]) } } return obj;} 实现jsonp script标签不受跨域资源请求的影响，可以通过增加callback参数将回调函数传递，与服务器端配合从而在资源加载之后执行该回调函数 1&lt;script src=\"http://localhost:3000/jsonp?callback=test\"&gt;&lt;/script&gt; 在服务器端，需要对script的src进行url解析，将data作为参数放入回调函数中，最后通过res.end(callback(data))中将要执行的函数放入客户端的script中，在客户端对该函数进行执行 12345678910111213141516//解析urlvar urlPath = url.parse(req.url).pathname;console.log(urlPath);//获取从客户端传递的参数var qs = querystring.parse(req.url.split('?')[1]);//约定的url的名称为jsonpif(urlPath === '/jsonp' &amp;&amp; qs.callback){ res.writeHead(200,{'Content-Type':'application/json;charset=utf-8'}); var data = { \"name\": \"Monkey\" }; data = JSON.stringify(data); var callback = qs.callback+'('+data+');'; //在end中返回callback(data)，写入script中，进而客户端进行该函数的执行 res.end(callback);} 因为客户端是通过script请求的，获取的内容会放在中，而res.end(data)中的data就会放到script中，浏览器会自动调用其内部代码执行，从而完成回调函数的执行） 实现正则切分千分位（10000 =&gt; 10,000） num.toString().replace(/\\B(?=(?:\\d{3})+$)/g, ‘,’) 手写apply, call, bind call的实现 123456789101112131415//传递参数从一个数组变成逐个传参了,不用...扩展运算符的也可以用arguments代替Function.prototype.myCall = function (context, ...args) { //这里默认不传就是给window,也可以用es6给参数设置默认参数 context = context || window args = args ? args : [] //给context新增一个独一无二的属性以免覆盖原有属性 const key = Symbol() context[key] = this //通过隐式绑定的方式调用函数 const result = context[key](...args) //删除添加的属性 delete context[key] //返回函数调用的返回值 return result} apply的实现 1234567891011121314Function.prototype.myApply = function (context, args) { //这里默认不传就是给window,也可以用es6给参数设置默认参数 context = context || window args = args ? args : [] //给context新增一个独一无二的属性以免覆盖原有属性 const key = Symbol() context[key] = this //通过隐式绑定的方式调用函数 const result = context[key](...args) //删除添加的属性 delete context[key] //返回函数调用的返回值 return result} bind 12345678910Function.prototype.myBind = function (context, ...args) { const fn = this args = args ? args : [] return function newFn(...newFnArgs) { if (this instanceof newFn) { return new fn(...args, ...newFnArgs) } return fn.apply(context, [...args,...newFnArgs]) }}","link":"/2020/05/28/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%982/"}],"tags":[],"categories":[]}